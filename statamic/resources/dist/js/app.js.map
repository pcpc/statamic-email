{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar vm = new Vue({\n    el: '#statamic',\n\n    data: {\n        isPublishPage: false,\n        isPreviewing: false,\n        showShortcuts: false,\n        navVisible: false,\n        version: Statamic.version,\n        flashSuccess: Statamic.flashSuccess,\n        flashError: false,\n        flashSuccessTimer: null,\n        draggingNonFile: false,\n        sneakPeekViewport: null,\n        sneakPeekFields: null\n    },\n\n    computed: {\n        hasSearchResults: function hasSearchResults() {\n            return this.$refs.search.hasItems;\n        }\n    },\n\n    methods: {\n        preview: function preview() {\n            var _this = this;\n\n            var self = this;\n            self.$broadcast('previewing');\n            self.isPreviewing = true;\n\n            this.sneakPeekViewport = $('.sneak-peek-viewport')[0];\n            this.sneakPeekFields = $('.page-wrapper')[0];\n\n            $('.sneak-peek-wrapper').addClass('animating on');\n\n            this.wait(200).then(function () {\n                var width = localStorage.getItem('statamic.sneakpeek.width') || 400;\n                _this.sneakPeekViewport.style.left = width + 'px';\n                _this.sneakPeekFields.style.width = width + 'px';\n                $(_this.$el).addClass('sneak-peeking');\n                return _this.wait(200);\n            }).then(function () {\n                $('#sneak-peek-iframe').show();\n                $(_this.$el).addClass('sneak-peek-editing sneak-peek-animating');\n                return _this.wait(500);\n            }).then(function () {\n                $(_this.$el).removeClass('sneak-peek-animating');\n            });\n        },\n\n        stopPreviewing: function stopPreviewing() {\n            var _this2 = this;\n\n            this.isPreviewing = false;\n            this.$broadcast('previewing.stopped');\n\n            $('.sneak-peek-wrapper').addClass('animating');\n            $(this.$el).addClass('sneak-peek-animating');\n            $(this.$el).removeClass('sneak-peek-editing');\n            $('#sneak-peek-iframe').fadeOut();\n            $('.sneak-peek-wrapper .icon').hide();\n\n            this.wait(500).then(function () {\n                _this2.sneakPeekViewport.style.left = null;\n                _this2.sneakPeekFields.style.width = null;\n                $(_this2.$el).removeClass('sneak-peek-animating');\n                $(_this2.$el).removeClass('sneak-peeking');\n                return _this2.wait(200);\n            }).then(function () {\n                $('.sneak-peek-wrapper').removeClass('on');\n                return _this2.wait(200);\n            }).then(function () {\n                $('.sneak-peek-wrapper').removeClass('animating');\n            });\n        },\n\n        /**\n         * Returns a promise after specified milliseconds\n         *\n         * A nice alternative to nested setTimeouts.\n         */\n        wait: function wait(ms) {\n            return new Promise(function (resolve) {\n                setTimeout(resolve, ms);\n            });\n        },\n\n\n        toggleNav: function toggleNav() {\n            this.navVisible = !this.navVisible;\n        },\n\n        /**\n         * When the dragstart event is triggered.\n         *\n         * This event doesn't get triggered when dragging something from outside the browser,\n         * so we can determine that something other than a file is being dragged.\n         */\n        dragStart: function dragStart() {\n            this.draggingNonFile = true;\n        },\n\n\n        /**\n         * When the dragend event is triggered.\n         *\n         * This event doesn't get triggered when dragging something from outside the browser,\n         * so we can determine that something other than a file is being dragged.\n         */\n        dragEnd: function dragEnd() {\n            this.draggingNonFile = false;\n        },\n        sneakPeekResizeStart: function sneakPeekResizeStart(e) {\n            window.addEventListener('mousemove', this.sneakPeekResizing);\n            window.addEventListener('mouseup', this.sneakPeekResizeEnd);\n            $('.sneak-peek-iframe-wrap').css('pointer-events', 'none');\n        },\n        sneakPeekResizeEnd: function sneakPeekResizeEnd(e) {\n            window.removeEventListener('mousemove', this.sneakPeekResizing, false);\n            window.removeEventListener('mouseup', this.sneakPeekResizeEnd, false);\n            $('.sneak-peek-iframe-wrap').css('pointer-events', 'auto');\n        },\n        sneakPeekResizing: function sneakPeekResizing(e) {\n            e.preventDefault();\n\n            var width = e.clientX;\n\n            // Prevent the width being too narrow.\n            width = width < 350 ? 350 : width;\n\n            this.sneakPeekViewport.style.left = width + 'px';\n            this.sneakPeekFields.style.width = width + 'px';\n\n            localStorage.setItem('statamic.sneakpeek.width', width);\n        },\n        stickyHeader: function stickyHeader() {\n            var header = $('.sticky').first();\n\n            if (!header.length) return;\n\n            document.addEventListener('scroll', function (e) {\n                var win = $(window);\n                header.parent().toggleClass('stuck', win.scrollTop() > 90);\n            });\n        }\n    },\n\n    ready: function ready() {\n        var _this3 = this;\n\n        Mousetrap.bind(['/', 'ctrl+f'], function (e) {\n            $('#global-search').focus();\n        }, 'keyup');\n\n        Mousetrap.bind('?', function (e) {\n            this.showShortcuts = true;\n        }.bind(this), 'keyup');\n\n        Mousetrap.bind('escape', function (e) {\n            this.$broadcast('close-modal');\n            this.$broadcast('close-editor');\n            this.$broadcast('close-selector');\n            this.$broadcast('close-dropdown', null);\n        }.bind(this), 'keyup');\n\n        // Clear the initial flash message after a second.\n        this.flashSuccessTimer = setTimeout(function () {\n            _this3.flashSuccess = null;\n        }, 1000);\n\n        // Keep track of whether something other than a file is being dragged\n        // so that components can tell when a file is being dragged.\n        window.addEventListener('dragstart', this.dragStart);\n        window.addEventListener('dragend', this.dragEnd);\n\n        this.stickyHeader();\n    },\n\n    events: {\n        'setFlashSuccess': function setFlashSuccess(msg, timeout) {\n            var _this4 = this;\n\n            this.flashSuccess = msg;\n\n            clearTimeout(this.flashSuccessTimer);\n\n            if (timeout) {\n                this.flashSuccessTimer = setTimeout(function () {\n                    _this4.flashSuccess = null;\n                }, timeout);\n            }\n        },\n        'setFlashError': function setFlashError(msg) {\n            this.flashError = msg;\n        },\n        'changesMade': function changesMade(changed) {\n            // If true, a confirmation dialog will be displayed when the user tries to\n            // navigate away (or refresh, etc). If false, the dialog will no longer show.\n            if (changed) {\n                window.onbeforeunload = function () {\n                    return '';\n                };\n            } else {\n                window.onbeforeunload = null;\n            }\n        }\n    }\n});\n\n},{}]},{},[1]);\n"],"file":"app.js"}